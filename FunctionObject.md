# 함수 객체 
 >  함수처럼 동작하는 객체
 
 > 함수처럼 동작하기 위해선 객체가 '()'연산자를 정의해야 한다.
 > > 다시말해 '()'연산자를 오버로딩한 객체 
 > > 함수 객체는 함수자(Functor)라 불리기도 합니다.

 ```cpp
    void Print(){
        cout<< "전역함수"<<endl;
    }
    struct Functor
    {
        void operator() ()
        {
            cout<<"함수 객체!"<<endl;
        }
        void operator() (int a, int b)
        {
            
        }
    };


    int main(){
        Functor functor;

        Print();
        functor(); // functor.operator()와 같다.
        functor(10,20);

        return 0;
    }
 ```
 ## 일반 함수 말고 함수 객체를 사용하는 이유(장점)
  1. 함수객체는 함수처럼 동작하는 객체이므로 다른 멤버 변수와 멤버 함수를 가질 수 있다.
  2. 일반 함수에서 하지 못하는 지원을 받을 수 있다. 
        - 무슨 지원?
            * 내부적인 상태 값을 가질 수 있다.[예3-3]
                * 클래스 내 멤버 변수(total)가 이전값을 포함한 채로 동작한다.         

  3. 함수객체의 이름이 같더라도 객체 타입이 다르면 서로다른 객체로 인식
  4. 속도가 일반 함수 보다 빠르다
  5. 함수 주소를 전달하여 콜백하는 경우 이 함수 포인터는 인라인될 수 없지만(함수 포인터는 인라인 함수의 복사본 함수를 만들어냄[질문]) 함수 객체는 
  인라인 될 수 있고, 컴파일러가 쉽게 최적화할 수 있습니다.
        - 이해 못하겠다.
            * [예3-3]에서 operator()(int a)함수는 클래스 내부에 정의되므로 암묵적으로 인라인 함수가 된다.
            * [질 문] operator()(int a)와 서명이 같더라도 타입이 다른 함수 객체는 Adder클래스 객체에 대한 대입하거나 복사할수 없음

```cpp
/*[예 3-3]*/
    class Adder
    {
        int total;
    public:
        explicit Adder(int n=0): total(n){ }
        int operator() (int a){
            return total+=a;
        }
    }
    int main(){
        Adder add(0);

        cout<<add(10)<< endl;   // return value : 10
        cout<<add(20)<< endl;   // return value : 30   
        cout<<add(30)<< endl;   // return value : 60
        
    }
```

 ## 인라인 함수(inline function)는 여러 버전의 C와 C++ 프로그래밍 언어에서 컴파일러가 인라인 확장 수행을 요청 받는 함수이다.
 > [보고 토의하기] https://namu.wiki/w/%EC%9D%B8%EB%9D%BC%EC%9D%B8%20%ED%95%A8%EC%88%98

 > C/C++ 언어에서 사용할 수 있는 기능으로, 함수 호출 시 별도로 분리된 위치의 레이블로 점프하여 실행되는 일반 함수와는 달리 호출 부분을 함수 전체 코드로 치환하여 컴파일한다. 전처리기의 매크로와 달리 언어 차원에서 지원하기에 일반 함수와 별 다르지 않게 사용할 수 있다.
 사용방법은 무척 심플한데, inline을 함수 선언시 붙여주면 된다. 다만 이것은 컴파일러에게 주는 힌트일 뿐 항상 인라이닝을 하는 것을 보장하지 않는다. 가령 대부분의 컴파일러는 비용 분석을 통해 인라이닝이 손해라고 판단하면 코드에서 아무리 inline을 붙여도 인라이닝을 포기한다. 

 > 참고로, 최신의 컴파일러의 경우는 최적화 기능이 잘 되어 있기에 inline이 붙어 있지 않더라도 인라이닝을 하는게 이득이 된다고 판단되면, 그냥 알아서 인라이닝 처리를 해버린다. 
        
* 요약
    * 인라인 함수는 프로그램의 실행 속도를 높이기 위해 추가된 기능이며 C언어의 매크로 함수와 비교된다.

    * (개발자 입장에서)일반 함수와 인라인 함수의 가장 큰 차이점은 함수의 호출 방식이다.
    일반 함수의 호출 방법은 프로그램 실행 중 함수를 실행해야하면 해당 함수의 주소로 점프시켰다가,  
    함수의 처리가 종결되면 다시 원래의 자리로 돌아오는 것이다.
    이렇게 앞뒤로 점프를 수행하고, 점프할 위치를 기억하려면 함수를 사용하는데 시간이 많이 걸린다.

    * 인라인 함수는 컴파일된 함수 코드가 프로그램의 코드 안에 직접 삽입되어진다.
    이 말은 컴파일러가 함수를 호출하는 대신, 그에 대응하는 함수 코드로 대체한다는 것을 의미하며 
    함수 호출없이 삽입된 함수 코드를 그 자리에서 처리하므로 해당 함수를 수행하기 위해 
    프로그램이 다른 주소로 점프했다가 되돌아 올 필요가 없어 속도면에서 유리하다.

1. 짧은 함수를 인라인 함수로 사용해야 한다.
    * 함수 호출 비용을 절약한다.
    * 짧은 인라인 함수는 함수 호출문에 대해 만들어지는 코드보다 목적 코드가 작아질 수 있다.
    * 캐시 적중율이 높아진다.

2. 코드 길이가 긴 인라인 함수는 사용하지 말자! 
    * 인라인 함수를 남용하게 되면, 컴파일 시에 코드 대체로 인한 목적 코드의 크기가 증가할 수 있다.

3. 가상 함수를 인라인 함수로 만들지 말자!
    * 가상 함수는 컴파일 시가 아닌, 프로그램 수행시 결정되므로 컴파일 시에 코드 대체되는 인라인 함수로는 사용될 수 없다.
    

  



